/// <reference path="HeartbeatService.d.ts" />
//
// Autogenerated by Thrift Compiler (0.14.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');
import shared_ttypes = require('./shared_types');


import ttypes = require('./projectmanager_types');
import ToolType = ttypes.ToolType
import InvocationType = ttypes.InvocationType
import NodeType = ttypes.NodeType
import OptionType = ttypes.OptionType
import PROJECTMANAGER_ID = ttypes.PROJECTMANAGER_ID
import ProjectManagerError = ttypes.ProjectManagerError
import ToolDefinition = ttypes.ToolDefinition
import Toolchain = ttypes.Toolchain
import Configuration = ttypes.Configuration
import ProjectContext = ttypes.ProjectContext
import Node = ttypes.Node
import OptionElementDescription = ttypes.OptionElementDescription
import OptionDescription = ttypes.OptionDescription
import OptionCategory = ttypes.OptionCategory
import HeartbeatService = require('./HeartbeatService');

/**
 * A service which manages Embedded Workbench project files (.ewp)
 * 
 * It can manipulate the project nodes and build configurations, as well as reading/writing
 * their respective settings.
 * 
 * There is also experimental to register new toolchains directly from the service, without
 * requirind an swtd static library. This is however very limited as of now in that there is
 * no option support for them.
 */
declare class Client extends HeartbeatService.Client {
  #output: thrift.TTransport;
  #pClass: thrift.TProtocol;
  #_seqid: number;

  constructor(output: thrift.TTransport, pClass: { new(trans: thrift.TTransport): thrift.TProtocol });

  /**
   * Create new, empty project with the provided file path
   */
  CreateEwpFile(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Create new, empty project with the provided file path
   */
  CreateEwpFile(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Load project from .ewp file
   */
  LoadEwpFile(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Load project from .ewp file
   */
  LoadEwpFile(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Save project to file specified in the context
   */
  SaveEwpFile(project: ProjectContext): Q.Promise<void>;

  /**
   * Save project to file specified in the context
   */
  SaveEwpFile(project: ProjectContext, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Get existing project context given file path
   */
  GetProject(file_path: string): Q.Promise<ProjectContext>;

  /**
   * Get existing project context given file path
   */
  GetProject(file_path: string, callback?: (error: ttypes.ProjectManagerError, response: ProjectContext)=>void): void;

  /**
   * Close loaded project, freeing the resources allocated for it by the project manager
   */
  CloseProject(project: ProjectContext): Q.Promise<void>;

  /**
   * Close loaded project, freeing the resources allocated for it by the project manager
   */
  CloseProject(project: ProjectContext, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Add a Configuration to a project
   */
  AddConfiguration(config: Configuration, project: ProjectContext, isDebug: boolean): Q.Promise<void>;

  /**
   * Add a Configuration to a project
   */
  AddConfiguration(config: Configuration, project: ProjectContext, isDebug: boolean, callback?: (error: void, response: void)=>void): void;

  /**
   * Remove a Configuration from a project given its name
   */
  RemoveConfiguration(configurationName: string, project: ProjectContext): Q.Promise<void>;

  /**
   * Remove a Configuration from a project given its name
   */
  RemoveConfiguration(configurationName: string, project: ProjectContext, callback?: (error: void, response: void)=>void): void;

  /**
   * Get all Configurations in a project
   */
  GetConfigurations(project: ProjectContext): Q.Promise<Configuration[]>;

  /**
   * Get all Configurations in a project
   */
  GetConfigurations(project: ProjectContext, callback?: (error: void, response: Configuration[])=>void): void;

  /**
   * Get the root of a project's file and group hierarchy tree, including all children
   */
  GetRootNode(ctx: ProjectContext): Q.Promise<Node>;

  /**
   * Get the root of a project's file and group hierarchy tree, including all children
   */
  GetRootNode(ctx: ProjectContext, callback?: (error: void, response: Node)=>void): void;

  /**
   * Set a node in the project's hierarchy, possibly replacing an existing subtree if a node with the same name already exists (e.g. the project root).
   */
  SetNode(ctx: ProjectContext, node: Node): Q.Promise<void>;

  /**
   * Set a node in the project's hierarchy, possibly replacing an existing subtree if a node with the same name already exists (e.g. the project root).
   */
  SetNode(ctx: ProjectContext, node: Node, callback?: (error: void, response: void)=>void): void;

  /**
   * Get a list of available Toolchains.
   */
  GetToolchains(): Q.Promise<Toolchain[]>;

  /**
   * Get a list of available Toolchains.
   */
  GetToolchains(callback?: (error: ttypes.ProjectManagerError, response: Toolchain[])=>void): void;

  /**
   * Register a toolchain with the project manager. Will fail if the toolchain is already registered.
   */
  AddToolchain(toolchain: Toolchain): Q.Promise<void>;

  /**
   * Register a toolchain with the project manager. Will fail if the toolchain is already registered.
   */
  AddToolchain(toolchain: Toolchain, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Build a project configuration asynchronously. Will notify the build result when done as an event.
   */
  BuildProject(prj: ProjectContext, configurationName: string): Q.Promise<void>;

  /**
   * Build a project configuration asynchronously. Will notify the build result when done as an event.
   */
  BuildProject(prj: ProjectContext, configurationName: string, callback?: (error: ttypes.ProjectManagerError, response: void)=>void): void;

  /**
   * Get a list of options for the given node (file, group) in a project, within the given configuration .
   */
  GetOptionsForNode(prj: ProjectContext, node: Node, configurationName: string): Q.Promise<OptionDescription[]>;

  /**
   * Get a list of options for the given node (file, group) in a project, within the given configuration .
   */
  GetOptionsForNode(prj: ProjectContext, node: Node, configurationName: string, callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Get a list of options for the given build configuration in a project.
   */
  GetOptionsForConfiguration(prj: ProjectContext, configurationName: string): Q.Promise<OptionDescription[]>;

  /**
   * Get a list of options for the given build configuration in a project.
   */
  GetOptionsForConfiguration(prj: ProjectContext, configurationName: string, callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Set a list of options for the given node (file, group) in a project. Return a list of updated options.
   */
  ApplyOptionsForNode(prj: ProjectContext, node: Node, configurationName: string, optionsToSet: OptionDescription[]): Q.Promise<OptionDescription[]>;

  /**
   * Set a list of options for the given node (file, group) in a project. Return a list of updated options.
   */
  ApplyOptionsForNode(prj: ProjectContext, node: Node, configurationName: string, optionsToSet: OptionDescription[], callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Set a list of options for the given node (file, group) in a project without saving to the EWP file. Return a list of updated options.
   */
  VerifyOptionsForNode(prj: ProjectContext, node: Node, configurationName: string, optionsToSet: OptionDescription[]): Q.Promise<OptionDescription[]>;

  /**
   * Set a list of options for the given node (file, group) in a project without saving to the EWP file. Return a list of updated options.
   */
  VerifyOptionsForNode(prj: ProjectContext, node: Node, configurationName: string, optionsToSet: OptionDescription[], callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Set a list of options for the given build configuration in a project. Return a list of updated options.
   */
  ApplyOptionsForConfiguration(prj: ProjectContext, configurationName: string, optionsToSet: OptionDescription[]): Q.Promise<OptionDescription[]>;

  /**
   * Set a list of options for the given build configuration in a project. Return a list of updated options.
   */
  ApplyOptionsForConfiguration(prj: ProjectContext, configurationName: string, optionsToSet: OptionDescription[], callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Set a list of options for the given build configuration in a project without saving to the EWP file. Return a list of updated options.
   */
  VerifyOptionsForConfiguration(prj: ProjectContext, configurationName: string, optionsToSet: OptionDescription[]): Q.Promise<OptionDescription[]>;

  /**
   * Set a list of options for the given build configuration in a project without saving to the EWP file. Return a list of updated options.
   */
  VerifyOptionsForConfiguration(prj: ProjectContext, configurationName: string, optionsToSet: OptionDescription[], callback?: (error: ttypes.ProjectManagerError, response: OptionDescription[])=>void): void;

  /**
   * Get a list of option categories for a given configuration
   */
  GetOptionCategories(prj: ProjectContext, configurationName: string): Q.Promise<OptionCategory[]>;

  /**
   * Get a list of option categories for a given configuration
   */
  GetOptionCategories(prj: ProjectContext, configurationName: string, callback?: (error: void, response: OptionCategory[])=>void): void;

  /**
   * Enable/disable multi-file compilation for the provided project, configuration and project node
   */
  EnableMultiFileCompilation(prj: ProjectContext, configurationName: string, node: Node, enabled: boolean): Q.Promise<void>;

  /**
   * Enable/disable multi-file compilation for the provided project, configuration and project node
   */
  EnableMultiFileCompilation(prj: ProjectContext, configurationName: string, node: Node, enabled: boolean, callback?: (error: void, response: void)=>void): void;

  /**
   * Enable/disable multi-file 'discard public symbols' for the provided project, configuration and project node
   */
  EnableMultiFileDiscardPublicSymbols(prj: ProjectContext, configurationName: string, node: Node, enabled: boolean): Q.Promise<void>;

  /**
   * Enable/disable multi-file 'discard public symbols' for the provided project, configuration and project node
   */
  EnableMultiFileDiscardPublicSymbols(prj: ProjectContext, configurationName: string, node: Node, enabled: boolean, callback?: (error: void, response: void)=>void): void;

  /**
   * Returns whether multi-file compilation is enabled for the provided project, configuration and project node
   */
  IsMultiFileCompilationEnabled(prj: ProjectContext, configurationName: string, node: Node): Q.Promise<boolean>;

  /**
   * Returns whether multi-file compilation is enabled for the provided project, configuration and project node
   */
  IsMultiFileCompilationEnabled(prj: ProjectContext, configurationName: string, node: Node, callback?: (error: void, response: boolean)=>void): void;

  /**
   * Enable/disable multi-file 'discard public symbols' for the provided project, configuration and project node
   */
  IsMultiFileDiscardPublicSymbolsEnabled(prj: ProjectContext, configurationName: string, node: Node): Q.Promise<boolean>;

  /**
   * Enable/disable multi-file 'discard public symbols' for the provided project, configuration and project node
   */
  IsMultiFileDiscardPublicSymbolsEnabled(prj: ProjectContext, configurationName: string, node: Node, callback?: (error: void, response: boolean)=>void): void;
}

declare class Processor extends HeartbeatService.Processor {
  #_handler: object;

  constructor(handler: object);
  process(input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_CreateEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_LoadEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_SaveEwpFile(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_CloseProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_AddConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_RemoveConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetConfigurations(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetRootNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_SetNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetToolchains(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_AddToolchain(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_BuildProject(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetOptionsForNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetOptionsForConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_ApplyOptionsForNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_VerifyOptionsForNode(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_ApplyOptionsForConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_VerifyOptionsForConfiguration(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_GetOptionCategories(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_EnableMultiFileCompilation(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_EnableMultiFileDiscardPublicSymbols(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_IsMultiFileCompilationEnabled(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
  process_IsMultiFileDiscardPublicSymbolsEnabled(seqid: number, input: thrift.TProtocol, output: thrift.TProtocol): void;
}
